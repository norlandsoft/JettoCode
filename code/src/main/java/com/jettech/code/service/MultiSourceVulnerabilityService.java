package com.jettech.code.service;

import com.jettech.code.dto.VulnerabilityInfo;
import com.jettech.code.provider.VulnerabilitySource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

@Service
public class MultiSourceVulnerabilityService {
    
    private static final Logger logger = LoggerFactory.getLogger(MultiSourceVulnerabilityService.class);
    
    private final List<VulnerabilitySource> sources;
    private final VulnerabilityCacheService cacheService;
    
    public MultiSourceVulnerabilityService(List<VulnerabilitySource> sources, 
                                            VulnerabilityCacheService cacheService) {
        this.sources = sources.stream()
            .sorted(Comparator.comparingInt(VulnerabilitySource::getPriority))
            .collect(Collectors.toList());
        this.cacheService = cacheService;
    }
    
    public List<VulnerabilityInfo> queryAllSources(String packageName, String ecosystem, String version) {
        List<VulnerabilityInfo> cachedResults = cacheService.get(packageName, ecosystem, version);
        if (cachedResults != null) {
            logger.info("Using cached vulnerabilities for {}@{} in {}", packageName, version, ecosystem);
            return cachedResults;
        }
        
        logger.info("Querying {} vulnerability sources for {}@{} in {}", sources.size(), packageName, version, ecosystem);
        
        List<CompletableFuture<List<VulnerabilityInfo>>> futures = sources.stream()
            .map(source -> CompletableFuture.supplyAsync(() -> {
                try {
                    logger.debug("Querying {} for {}@{}", source.getName(), packageName, version);
                    List<VulnerabilityInfo> results = source.query(packageName, ecosystem, version);
                    logger.info("{} returned {} vulnerabilities for {}@{}", source.getName(), results.size(), packageName, version);
                    return results;
                } catch (Exception e) {
                    logger.error("{} failed to query {}@{}: {}", source.getName(), packageName, version, e.getMessage());
                    return Collections.<VulnerabilityInfo>emptyList();
                }
            }))
            .collect(Collectors.toList());
        
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
        
        List<VulnerabilityInfo> allVulnerabilities = futures.stream()
            .map(CompletableFuture::join)
            .flatMap(List::stream)
            .collect(Collectors.toList());
        
        List<VulnerabilityInfo> mergedResults = mergeAndDeduplicate(allVulnerabilities);
        
        if (!mergedResults.isEmpty()) {
            cacheService.save(packageName, ecosystem, version, mergedResults);
        }
        
        logger.info("Total unique vulnerabilities found for {}@{}: {}", packageName, version, mergedResults.size());
        
        return mergedResults;
    }
    
    private List<VulnerabilityInfo> mergeAndDeduplicate(List<VulnerabilityInfo> vulnerabilities) {
        Map<String, VulnerabilityInfo> uniqueVulns = new LinkedHashMap<>();
        
        for (VulnerabilityInfo vuln : vulnerabilities) {
            String key = vuln.getCveId() != null ? vuln.getCveId() : vuln.getId();
            
            if (key == null) {
                key = UUID.randomUUID().toString();
            }
            
            VulnerabilityInfo existing = uniqueVulns.get(key);
            
            if (existing == null) {
                uniqueVulns.put(key, vuln);
            } else {
                existing = mergeVulnerabilityInfo(existing, vuln);
                uniqueVulns.put(key, existing);
            }
        }
        
        return new ArrayList<>(uniqueVulns.values());
    }
    
    private VulnerabilityInfo mergeVulnerabilityInfo(VulnerabilityInfo existing, VulnerabilityInfo newInfo) {
        if (newInfo.getCvssScore() != null && existing.getCvssScore() != null) {
            if (newInfo.getCvssScore() > existing.getCvssScore()) {
                existing.setCvssScore(newInfo.getCvssScore());
                existing.setSeverity(newInfo.getSeverity());
            }
        }
        
        if (existing.getDescription() == null && newInfo.getDescription() != null) {
            existing.setDescription(newInfo.getDescription());
        }
        
        if (existing.getFixedVersion() == null || "unknown".equals(existing.getFixedVersion())) {
            if (newInfo.getFixedVersion() != null && !"unknown".equals(newInfo.getFixedVersion())) {
                existing.setFixedVersion(newInfo.getFixedVersion());
            }
        }
        
        String existingSource = existing.getSource();
        String newSource = newInfo.getSource();
        if (existingSource != null && newSource != null && !existingSource.contains(newSource)) {
            existing.setSource(existingSource + "," + newSource);
        }
        
        return existing;
    }
    
    public void clearCache() {
        cacheService.clearAll();
    }
    
    public void clearExpiredCache() {
        cacheService.clearExpired();
    }
}
