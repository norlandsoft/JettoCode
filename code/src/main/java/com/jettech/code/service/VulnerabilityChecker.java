package com.jettech.code.service;

import com.jettech.code.client.OsvApiClient;
import com.jettech.code.client.OsvApiClient.OsvVulnerability;
import com.jettech.code.client.OsvApiClient.PackageQuery;
import com.jettech.code.entity.Dependency;
import com.jettech.code.entity.Vulnerability;
import com.jettech.code.mapper.VulnerabilityMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class VulnerabilityChecker {
    
    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityChecker.class);
    
    private final OsvApiClient osvApiClient;
    private final VulnerabilityMapper vulnerabilityMapper;
    
    private final Map<String, List<OsvVulnerability>> vulnerabilityCache = new ConcurrentHashMap<>();
    
    private static final Map<String, String> ECOSYSTEM_MAPPING = Map.of(
        "maven", "Maven",
        "npm", "npm",
        "pypi", "PyPI",
        "golang", "Go"
    );

    public VulnerabilityChecker(OsvApiClient osvApiClient, VulnerabilityMapper vulnerabilityMapper) {
        this.osvApiClient = osvApiClient;
        this.vulnerabilityMapper = vulnerabilityMapper;
    }
    
    public List<Vulnerability> checkVulnerabilities(Dependency dependency) {
        vulnerabilityMapper.deleteByDependencyId(dependency.getId());
        
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        List<OsvVulnerability> osvVulns = queryOsv(dependency);
        
        for (OsvVulnerability osvVuln : osvVulns) {
            Vulnerability vuln = convertToVulnerability(dependency.getId(), osvVuln);
            if (vuln != null) {
                vulnerabilities.add(vuln);
            }
        }
        
        if (!vulnerabilities.isEmpty()) {
            vulnerabilityMapper.batchInsert(vulnerabilities);
        }
        
        return vulnerabilities;
    }
    
    public Map<Long, List<Vulnerability>> batchCheckVulnerabilities(List<Dependency> dependencies) {
        Map<Long, List<Vulnerability>> results = new HashMap<>();
        
        for (Dependency dep : dependencies) {
            vulnerabilityMapper.deleteByDependencyId(dep.getId());
        }
        
        List<PackageQuery> queries = new ArrayList<>();
        Map<String, Long> queryToDependencyId = new HashMap<>();
        
        for (Dependency dep : dependencies) {
            String ecosystem = mapEcosystem(dep.getType());
            if (ecosystem != null && dep.getVersion() != null && !dep.getVersion().equals("managed")) {
                String key = dep.getName() + "@" + dep.getVersion() + ":" + ecosystem;
                if (!queryToDependencyId.containsKey(key)) {
                    queries.add(new PackageQuery(dep.getName(), ecosystem, dep.getVersion()));
                    queryToDependencyId.put(key, dep.getId());
                }
            }
        }
        
        Map<String, List<OsvVulnerability>> osvResults;
        if (!queries.isEmpty()) {
            if (queries.size() > 1000) {
                osvResults = new HashMap<>();
                for (int i = 0; i < queries.size(); i += 1000) {
                    int end = Math.min(i + 1000, queries.size());
                    List<PackageQuery> batch = queries.subList(i, end);
                    osvResults.putAll(osvApiClient.batchQueryVulnerabilities(batch));
                }
            } else {
                osvResults = osvApiClient.batchQueryVulnerabilities(queries);
            }
        } else {
            osvResults = Map.of();
        }
        
        List<Vulnerability> allVulnerabilities = new ArrayList<>();
        
        for (Dependency dep : dependencies) {
            String ecosystem = mapEcosystem(dep.getType());
            if (ecosystem == null || dep.getVersion() == null || dep.getVersion().equals("managed")) {
                results.put(dep.getId(), List.of());
                continue;
            }
            
            String key = dep.getName() + "@" + dep.getVersion();
            List<OsvVulnerability> osvVulns = osvResults.getOrDefault(key, List.of());
            
            List<Vulnerability> depVulns = new ArrayList<>();
            for (OsvVulnerability osvVuln : osvVulns) {
                Vulnerability vuln = convertToVulnerability(dep.getId(), osvVuln);
                if (vuln != null) {
                    depVulns.add(vuln);
                    allVulnerabilities.add(vuln);
                }
            }
            
            results.put(dep.getId(), depVulns);
        }
        
        if (!allVulnerabilities.isEmpty()) {
            vulnerabilityMapper.batchInsert(allVulnerabilities);
        }
        
        return results;
    }
    
    private List<OsvVulnerability> queryOsv(Dependency dependency) {
        String ecosystem = mapEcosystem(dependency.getType());
        if (ecosystem == null) {
            return List.of();
        }
        
        String version = dependency.getVersion();
        if (version == null || version.equals("managed") || version.equals("unknown") || version.equals("latest")) {
            return List.of();
        }
        
        String cacheKey = dependency.getName() + "@" + version + ":" + ecosystem;
        if (vulnerabilityCache.containsKey(cacheKey)) {
            return vulnerabilityCache.get(cacheKey);
        }
        
        List<OsvVulnerability> vulns = osvApiClient.queryVulnerabilities(
            dependency.getName(), ecosystem, version
        );
        
        vulnerabilityCache.put(cacheKey, vulns);
        
        return vulns;
    }
    
    private Vulnerability convertToVulnerability(Long dependencyId, OsvVulnerability osvVuln) {
        if (osvVuln == null || osvVuln.id == null) {
            return null;
        }
        
        Vulnerability vuln = new Vulnerability();
        vuln.setDependencyId(dependencyId);
        vuln.setCveId(osvVuln.cveId != null ? osvVuln.cveId : osvVuln.id);
        vuln.setTitle(osvVuln.summary != null ? osvVuln.summary : osvVuln.id);
        vuln.setDescription(osvVuln.details);
        vuln.setSeverity(osvVuln.getNormalizedSeverity());
        
        Double cvssScore = osvVuln.getCvssScore();
        vuln.setCvssScore(cvssScore != null ? cvssScore : estimateCvssScore(osvVuln.getNormalizedSeverity()));
        
        vuln.setAffectedVersion(osvVuln.introducedVersion != null ? 
            ">= " + osvVuln.introducedVersion : "unknown");
        vuln.setFixedVersion(osvVuln.fixedVersion != null ? 
            ">= " + osvVuln.fixedVersion : "unknown");
        vuln.setReferences(osvVuln.references);
        vuln.setStatus("OPEN");
        vuln.setCreatedAt(LocalDateTime.now());
        
        return vuln;
    }
    
    private double estimateCvssScore(String severity) {
        return switch (severity) {
            case "CRITICAL" -> 9.5;
            case "HIGH" -> 7.5;
            case "MEDIUM" -> 5.0;
            case "LOW" -> 2.5;
            default -> 5.0;
        };
    }
    
    private String mapEcosystem(String type) {
        if (type == null) return null;
        return ECOSYSTEM_MAPPING.get(type.toLowerCase());
    }
    
    public void clearCache() {
        vulnerabilityCache.clear();
    }
}
