package com.jettech.code.service;

import com.jettech.code.dto.VulnerabilityInfo;
import com.jettech.code.entity.Dependency;
import com.jettech.code.entity.Vulnerability;
import com.jettech.code.mapper.VulnerabilityMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

@Service
public class VulnerabilityChecker {
    
    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityChecker.class);
    
    private final MultiSourceVulnerabilityService multiSourceService;
    private final VulnerabilityMapper vulnerabilityMapper;
    
    private static final Map<String, String> ECOSYSTEM_MAPPING = Map.of(
        "maven", "Maven",
        "npm", "npm",
        "pypi", "PyPI",
        "golang", "Go"
    );

    public VulnerabilityChecker(MultiSourceVulnerabilityService multiSourceService,
                                VulnerabilityMapper vulnerabilityMapper) {
        this.multiSourceService = multiSourceService;
        this.vulnerabilityMapper = vulnerabilityMapper;
    }
    
    public List<Vulnerability> checkVulnerabilities(Dependency dependency) {
        vulnerabilityMapper.deleteByDependencyId(dependency.getId());
        
        String ecosystem = mapEcosystem(dependency.getType());
        if (ecosystem == null || !isValidVersion(dependency.getVersion())) {
            return List.of();
        }
        
        List<VulnerabilityInfo> vulnInfos = multiSourceService.queryAllSources(
            dependency.getName(), ecosystem, dependency.getVersion()
        );
        
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        for (VulnerabilityInfo info : vulnInfos) {
            Vulnerability vuln = convertToVulnerability(dependency.getId(), info);
            if (vuln != null) {
                vulnerabilities.add(vuln);
            }
        }
        
        if (!vulnerabilities.isEmpty()) {
            vulnerabilityMapper.batchInsert(vulnerabilities);
        }
        
        return vulnerabilities;
    }
    
    @Transactional
    public Map<Long, List<Vulnerability>> batchCheckVulnerabilities(List<Dependency> dependencies) {
        Map<Long, List<Vulnerability>> results = new HashMap<>();
        
        for (Dependency dep : dependencies) {
            vulnerabilityMapper.deleteByDependencyId(dep.getId());
        }
        
        List<Dependency> validDependencies = dependencies.stream()
            .filter(dep -> mapEcosystem(dep.getType()) != null)
            .filter(dep -> isValidVersion(dep.getVersion()))
            .collect(Collectors.toList());
        
        if (validDependencies.isEmpty()) {
            dependencies.forEach(dep -> results.put(dep.getId(), List.of()));
            return results;
        }
        
        logger.info("Batch checking vulnerabilities for {} dependencies", validDependencies.size());
        
        List<CompletableFuture<Void>> futures = validDependencies.stream()
            .map(dep -> CompletableFuture.runAsync(() -> {
                try {
                    String ecosystem = mapEcosystem(dep.getType());
                    List<VulnerabilityInfo> vulnInfos = multiSourceService.queryAllSources(
                        dep.getName(), ecosystem, dep.getVersion()
                    );
                    
                    List<Vulnerability> vulns = vulnInfos.stream()
                        .map(info -> convertToVulnerability(dep.getId(), info))
                        .filter(Objects::nonNull)
                        .collect(Collectors.toList());
                    
                    synchronized (results) {
                        results.put(dep.getId(), vulns);
                    }
                } catch (Exception e) {
                    logger.error("Failed to check vulnerabilities for {}@{}: {}", 
                        dep.getName(), dep.getVersion(), e.getMessage());
                    synchronized (results) {
                        results.put(dep.getId(), List.of());
                    }
                }
            }))
            .collect(Collectors.toList());
        
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
        
        List<Vulnerability> allVulnerabilities = results.values().stream()
            .flatMap(List::stream)
            .collect(Collectors.toList());
        
        if (!allVulnerabilities.isEmpty()) {
            vulnerabilityMapper.batchInsert(allVulnerabilities);
            logger.info("Saved {} vulnerabilities to database", allVulnerabilities.size());
        }
        
        for (Dependency dep : dependencies) {
            if (!results.containsKey(dep.getId())) {
                results.put(dep.getId(), List.of());
            }
        }
        
        return results;
    }
    
    private Vulnerability convertToVulnerability(Long dependencyId, VulnerabilityInfo info) {
        if (info == null || info.getCveId() == null) {
            return null;
        }
        
        Vulnerability vuln = new Vulnerability();
        vuln.setDependencyId(dependencyId);
        vuln.setCveId(info.getCveId());
        vuln.setTitle(info.getTitle() != null ? info.getTitle() : info.getCveId());
        vuln.setDescription(info.getDescription());
        vuln.setSeverity(info.getSeverity() != null ? info.getSeverity() : "UNKNOWN");
        vuln.setCvssScore(info.getCvssScore() != null ? info.getCvssScore() : estimateCvssScore(info.getSeverity()));
        vuln.setAffectedVersion(info.getAffectedVersion() != null ? info.getAffectedVersion() : "unknown");
        vuln.setFixedVersion(info.getFixedVersion() != null ? info.getFixedVersion() : "unknown");
        vuln.setReferences(info.getReferences());
        vuln.setStatus("OPEN");
        vuln.setCreatedAt(LocalDateTime.now());
        
        return vuln;
    }
    
    private boolean isValidVersion(String version) {
        if (version == null) return false;
        String lower = version.toLowerCase();
        return !lower.equals("managed") && 
               !lower.equals("unknown") && 
               !lower.equals("latest") &&
               !lower.isEmpty();
    }
    
    private double estimateCvssScore(String severity) {
        if (severity == null) return 5.0;
        return switch (severity.toUpperCase()) {
            case "CRITICAL" -> 9.5;
            case "HIGH" -> 7.5;
            case "MEDIUM" -> 5.0;
            case "LOW" -> 2.5;
            default -> 5.0;
        };
    }
    
    private String mapEcosystem(String type) {
        if (type == null) return null;
        return ECOSYSTEM_MAPPING.get(type.toLowerCase());
    }
    
    public void clearCache() {
        multiSourceService.clearCache();
    }
    
    public void clearExpiredCache() {
        multiSourceService.clearExpiredCache();
    }
}
