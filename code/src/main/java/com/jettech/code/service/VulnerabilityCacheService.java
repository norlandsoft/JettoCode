package com.jettech.code.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.jettech.code.dto.VulnerabilityInfo;
import com.jettech.code.entity.VulnerabilityCache;
import com.jettech.code.mapper.VulnerabilityCacheMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Service
public class VulnerabilityCacheService {
    
    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityCacheService.class);
    
    private final VulnerabilityCacheMapper vulnerabilityCacheMapper;
    private final ObjectMapper objectMapper;
    
    @Value("${vulnerability.cache.expire-hours:24}")
    private int cacheExpireHours;
    
    public VulnerabilityCacheService(VulnerabilityCacheMapper vulnerabilityCacheMapper, 
                                      ObjectMapper objectMapper) {
        this.vulnerabilityCacheMapper = vulnerabilityCacheMapper;
        this.objectMapper = objectMapper;
    }
    
    public List<VulnerabilityInfo> get(String packageName, String ecosystem, String version) {
        VulnerabilityCache cache = vulnerabilityCacheMapper.findByPackagePatternAndEcosystem(
            buildCacheKey(packageName, ecosystem, version), ecosystem);
        
        if (cache != null && !isExpired(cache)) {
            return deserializeVulnerabilities(cache.getRawData());
        }
        
        return null;
    }
    
    @Transactional
    public void save(String packageName, String ecosystem, String version, List<VulnerabilityInfo> vulnerabilities) {
        if (vulnerabilities == null || vulnerabilities.isEmpty()) {
            return;
        }
        
        String cacheKey = buildCacheKey(packageName, ecosystem, version);
        
        vulnerabilityCacheMapper.deleteByPackagePattern(cacheKey);
        
        VulnerabilityCache cache = new VulnerabilityCache();
        cache.setPackagePattern(cacheKey);
        cache.setEcosystem(ecosystem);
        cache.setSource("MULTI");
        cache.setPriority(0);
        cache.setCreatedAt(LocalDateTime.now());
        cache.setExpiresAt(LocalDateTime.now().plusHours(cacheExpireHours));
        cache.setRawData(serializeVulnerabilities(vulnerabilities));
        
        vulnerabilityCacheMapper.insert(cache);
        
        logger.info("Cached {} vulnerabilities for {}@{} in {}", vulnerabilities.size(), packageName, version, ecosystem);
    }
    
    public void clearExpired() {
        int deleted = vulnerabilityCacheMapper.deleteExpired();
        if (deleted > 0) {
            logger.info("Cleared {} expired cache entries", deleted);
        }
    }
    
    public void clearAll() {
        vulnerabilityCacheMapper.clearAll();
        logger.info("Cleared all vulnerability cache");
    }
    
    private String buildCacheKey(String packageName, String ecosystem, String version) {
        return packageName + ":" + ecosystem + ":" + version;
    }
    
    private boolean isExpired(VulnerabilityCache cache) {
        return cache.getExpiresAt() != null && cache.getExpiresAt().isBefore(LocalDateTime.now());
    }
    
    private String serializeVulnerabilities(List<VulnerabilityInfo> vulnerabilities) {
        try {
            return objectMapper.writeValueAsString(vulnerabilities);
        } catch (JsonProcessingException e) {
            logger.error("Failed to serialize vulnerabilities", e);
            return "[]";
        }
    }
    
    @SuppressWarnings("unchecked")
    private List<VulnerabilityInfo> deserializeVulnerabilities(String rawData) {
        if (rawData == null || rawData.isEmpty()) {
            return new ArrayList<>();
        }
        
        try {
            return objectMapper.readValue(rawData, 
                objectMapper.getTypeFactory().constructCollectionType(List.class, VulnerabilityInfo.class));
        } catch (JsonProcessingException e) {
            logger.error("Failed to deserialize vulnerabilities", e);
            return new ArrayList<>();
        }
    }
}
